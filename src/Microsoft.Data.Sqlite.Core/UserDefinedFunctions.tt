<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
// <auto-generated />
using System;
using SQLitePCL;

namespace Microsoft.Data.Sqlite
{
    partial class SqliteConnection
    {
<#
    string[] ordinalNumberWords = { "", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth", "twentieth" };
        
    for (var i = 2; i <= 16; i++)
    {
        var typeArgs = Enumerable.Range(1, i).Select(j => "T" + j).ToList();
#>
        /// <summary>
        /// Create user defined function.
        /// </summary>
<#
        for (var j = 1; j <= i; j++)
        {
#>
        /// <typeparam name="T<#= j #>">The type of the <#= ordinalNumberWords[j] #> function argument.</typeparam>
<#
        }
#>
        /// <typeparam name="TResult">The type of the function result.</typeparam>
        /// <param name="name">Name of the function.</param>
        /// <param name="function">User defined function.</param>
        public virtual void CreateFunction<<#= string.Join(", ", typeArgs) #>, TResult>(
            string name,
            Func<<#= string.Join(", ", typeArgs) #>, TResult> function)
        {
            delegate_function_scalar scalarFunction = null;
            if (function != null)
            {
                scalarFunction = (ctx, _, args) =>
                {
                    if (args.Length < <#= i #>)
                    {
                        throw new ArgumentOutOfRangeException();
                    }

                    SetFunctionResult(
                        function(
<#
        for (var j = 1; j <= i-1; j++)
        {
#>
                            GetArgument<T<#= j #>>(args[<#= j-1 #>]),
<#
        }
#>
                            GetArgument<T<#= i #>>(args[<#= i-1 #>])),
                            ctx);
                };
            }

            CreateScalarFunction(name, <#= i #>, null, scalarFunction);
        }

<#
    }
#>
<#
    for (var i = 2; i <= 15; i++)
    {
        var typeArgs = Enumerable.Range(1, i).Select(j => "T" + j).ToList();
#>
        /// <summary>
        /// Create user defined function.
        /// </summary>
        /// <typeparam name="TState">The type of the state object.</typeparam>
<#
        for (var j = 1; j <= i; j++)
        {
#>
        /// <typeparam name="T<#= j #>">The type of the <#= ordinalNumberWords[j] #> function argument.</typeparam>
<#
        }
#>
        /// <typeparam name="TResult">The type of the function result.</typeparam>
        /// <param name="name">Name of the function.</param>
        /// <param name="state">State object passed to each invokation of the function.</param>
        /// <param name="function">User defined function.</param>
        public virtual void CreateFunction<TState, <#= string.Join(", ", typeArgs) #>, TResult>(
            string name,
            TState state,
            Func<TState, <#= string.Join(", ", typeArgs) #>, TResult> function)
        {
            delegate_function_scalar scalarFunction = null;
            if (function != null)
            {
                scalarFunction = (ctx, data, args) =>
                {
                    if (args.Length < <#= i #>)
                    {
                        throw new ArgumentOutOfRangeException();
                    }

                    SetFunctionResult(
                        function(
                            (TState)data,
<#
        for (var j = 1; j <= i-1; j++)
        {
#>
                            GetArgument<T<#= j #>>(args[<#= j-1 #>]),
<#
        }
#>
                            GetArgument<T<#= i #>>(args[<#= i-1 #>])),
                            ctx);
                };
            }

            CreateScalarFunction(name, <#= i #>, state, scalarFunction);
        }

<#
    }
#>
<#
    for (var i = 2; i <= 15; i++)
    {
        var typeArgs = Enumerable.Range(1, i).Select(j => "T" + j).ToList();
#>
        /// <summary>
        /// Create user defined aggregate.
        /// </summary>
        /// <typeparam name="TContext">Type of the state buffer.</typeparam>
<#
        for (var j = 1; j <= i; j++)
        {
#>
        /// <typeparam name="T<#= j #>">The type of the <#= ordinalNumberWords[j] #> function argument.</typeparam>
<#
        }
#>
        /// <param name="name">Name of the aggregate.</param>
        /// <param name="function">The user defined aggregate.</param>
        /// <returns>The seed value for the state buffer.</returns>
        public virtual TContext CreateAggregate<TContext, <#= string.Join(", ", typeArgs) #>>(
            string name,
            Func<TContext, <#= string.Join(", ", typeArgs) #>, TContext> function)
            => CreateAggregate(name, default(TContext), function);

        /// <summary>
        /// Create user defined aggregate.
        /// </summary>
        /// <typeparam name="TContext">Type of the state buffer.</typeparam>
<#
        for (var j = 1; j <= i; j++)
        {
#>
        /// <typeparam name="T<#= j #>">The type of the <#= ordinalNumberWords[j] #> function argument.</typeparam>
<#
        }
#>
        /// <param name="name">Name of the aggregate.</param>
        /// <param name="seed">Seed for initializing the aggregate.</param>
        /// <param name="function">The user defined aggregate.</param>
        /// <returns>The seed value for the state buffer.</returns>
        public virtual TContext CreateAggregate<TContext, <#= string.Join(", ", typeArgs) #>>(
            string name,
            TContext seed,
            Func<TContext, <#= string.Join(", ", typeArgs) #>, TContext> function)
            => CreateAggregate(name, seed, function, (state) => state);

        /// <summary>
        /// Create user defined aggregate.
        /// </summary>
        /// <typeparam name="TContext">Type of the state buffer.</typeparam>
<#
        for (var j = 1; j <= i; j++)
        {
#>
        /// <typeparam name="T<#= j #>">The type of the <#= ordinalNumberWords[j] #> function argument.</typeparam>
<#
        }
#>
        /// <typeparam name="TResult">Type returned by the result selector.</typeparam>
        /// <param name="name">Name of the aggregate.</param>
        /// <param name="seed">Seed for initializing the aggregate.</param>
        /// <param name="function">The user defined aggregate.</param>
        /// <param name="resultSelector">The user defined result selector.</param>
        /// <returns>The seed value for the state buffer.</returns>
        public virtual TResult CreateAggregate<TContext, <#= string.Join(", ", typeArgs) #>, TResult>(
            string name,
            TContext seed,
            Func<TContext, <#= string.Join(", ", typeArgs) #>, TContext> function,
            Func<TContext, TResult> resultSelector)
        {
            delegate_function_aggregate_step stepFunction = null;
            delegate_function_aggregate_final finalFunction = null;
            if (function != null)
            {
                stepFunction = (ctx, _, args) =>
                {
                    if (args.Length < <#= i #>)
                    {
                        throw new ArgumentOutOfRangeException();
                    }

                    if (ctx.state == null)
                    {
                        ctx.state = new StateValue<TContext> { Value = seed };
                    }

                    ((StateValue<TContext>)ctx.state).Value = function(
                        ((StateValue<TContext>)ctx.state).Value, 
<#
        for (var j = 1; j <= i-1; j++)
        {
#>
                        GetArgument<T<#= j #>>(args[<#= j-1 #>]),
<#
        }
#>
                        GetArgument<T<#= i #>>(args[<#= i-1 #>]));
                };

                finalFunction = (ctx, _) =>
                    SetFunctionResult(resultSelector(((StateValue<TContext>)ctx.state).Value), ctx);
            }

            CreateAggregateFunction(
                name, <#= i #>, stepFunction, finalFunction);
            return resultSelector(seed);
        }

<#
    }
#>
    }
}
